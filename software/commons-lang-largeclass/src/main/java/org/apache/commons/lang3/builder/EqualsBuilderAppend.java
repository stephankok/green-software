package org.apache.commons.lang3.builder;


public class EqualsBuilderAppend {
	/**
	* <p>Adds the result of <code>super.equals()</code> to this builder.</p>
	* @param superEquals   the result of calling <code>super.equals()</code>
	* @return  EqualsBuilder - used to chain calls.
	* @since  2.0
	*/
	public EqualsBuilder appendSuper(final boolean superEquals, EqualsBuilder equalsBuilder, boolean thisIsEquals) {
		if (!thisIsEquals) {
			return equalsBuilder;
		}
		equalsBuilder.setEquals(superEquals);
		return equalsBuilder;
	}

	/**
	* <p> Test if two <code>long</code> s are equal. </p>
	* @param lhs the left hand <code>long</code>
	* @param rhs the right hand <code>long</code>
	* @return  EqualsBuilder - used to chain calls.
	*/
	public EqualsBuilder append(final long lhs, final long rhs, EqualsBuilder equalsBuilder, boolean thisIsEquals) {
		if (!thisIsEquals) {
			return equalsBuilder;
		}
		equalsBuilder.setEquals(lhs == rhs);
		return equalsBuilder;
	}

	/**
	* <p>Test if two <code>double</code>s are equal by testing that the pattern of bits returned by <code>doubleToLong</code> are equal.</p> <p>This handles NaNs, Infinities, and <code>-0.0</code>.</p> <p>It is compatible with the hash code generated by <code>HashCodeBuilder</code>.</p>
	* @param lhs   the left hand <code>double</code>
	* @param rhs   the right hand <code>double</code>
	* @return  EqualsBuilder - used to chain calls.
	*/
	public EqualsBuilder append(final double lhs, final double rhs, boolean thisIsEquals, EqualsBuilder equalsBuilder) {
		if (!thisIsEquals) {
			return equalsBuilder;
		}
		return append(Double.doubleToLongBits(lhs), Double.doubleToLongBits(rhs), equalsBuilder, thisIsEquals);
	}

	/**
	* <p>Deep comparison of array of <code>long</code>. Length and all values are compared.</p> <p>The method  {@link #append(long,long)}  is used.</p>
	* @param lhs   the left hand <code>long[]</code>
	* @param rhs   the right hand <code>long[]</code>
	* @return  EqualsBuilder - used to chain calls.
	*/
	public EqualsBuilder append(final long[] lhs, final long[] rhs, boolean thisIsEquals, EqualsBuilder equalsBuilder) {
		if (!thisIsEquals) {
			return equalsBuilder;
		}
		if (lhs == rhs) {
			return equalsBuilder;
		}
		if (lhs == null || rhs == null) {
			equalsBuilder.setEquals(false);
			return equalsBuilder;
		}
		if (lhs.length != rhs.length) {
			equalsBuilder.setEquals(false);
			return equalsBuilder;
		}
		for (int i = 0; i < lhs.length && thisIsEquals; ++i) {
			append(lhs[i], rhs[i], equalsBuilder, thisIsEquals);
		}
		return equalsBuilder;
	}

	/**
	* <p>Deep comparison of array of <code>double</code>. Length and all values are compared.</p> <p>The method  {@link #append(double,double)}  is used.</p>
	* @param lhs   the left hand <code>double[]</code>
	* @param rhs   the right hand <code>double[]</code>
	* @return  EqualsBuilder - used to chain calls.
	*/
	public EqualsBuilder append(final double[] lhs, final double[] rhs, boolean thisIsEquals,
			EqualsBuilder equalsBuilder) {
		if (!thisIsEquals) {
			return equalsBuilder;
		}
		if (lhs == rhs) {
			return equalsBuilder;
		}
		if (lhs == null || rhs == null) {
			equalsBuilder.setEquals(false);
			return equalsBuilder;
		}
		if (lhs.length != rhs.length) {
			equalsBuilder.setEquals(false);
			return equalsBuilder;
		}
		for (int i = 0; i < lhs.length && thisIsEquals; ++i) {
			append(lhs[i], rhs[i], thisIsEquals, equalsBuilder);
		}
		return equalsBuilder;
	}

	/**
	* <p>Test if two <code>int</code>s are equal.</p>
	* @param lhs   the left hand <code>int</code>
	* @param rhs   the right hand <code>int</code>
	* @return  EqualsBuilder - used to chain calls.
	*/
	public EqualsBuilder append(final int lhs, final int rhs, EqualsBuilder equalsBuilder, boolean thisIsEquals) {
		if (!thisIsEquals) {
			return equalsBuilder;
		}
		equalsBuilder.setEquals(lhs == rhs);
		return equalsBuilder;
	}

	/**
	* <p>Test if two <code>float</code>s are equal byt testing that the pattern of bits returned by doubleToLong are equal.</p> <p>This handles NaNs, Infinities, and <code>-0.0</code>.</p> <p>It is compatible with the hash code generated by <code>HashCodeBuilder</code>.</p>
	* @param lhs   the left hand <code>float</code>
	* @param rhs   the right hand <code>float</code>
	* @return  EqualsBuilder - used to chain calls.
	*/
	public EqualsBuilder append(final float lhs, final float rhs, boolean thisIsEquals, EqualsBuilder equalsBuilder) {
		if (!thisIsEquals) {
			return equalsBuilder;
		}
		return append(Float.floatToIntBits(lhs), Float.floatToIntBits(rhs), equalsBuilder, thisIsEquals);
	}

	/**
	* <p>Deep comparison of array of <code>int</code>. Length and all values are compared.</p> <p>The method  {@link #append(int,int)}  is used.</p>
	* @param lhs   the left hand <code>int[]</code>
	* @param rhs   the right hand <code>int[]</code>
	* @return  EqualsBuilder - used to chain calls.
	*/
	public EqualsBuilder append(final int[] lhs, final int[] rhs, boolean thisIsEquals, EqualsBuilder equalsBuilder) {
		if (!thisIsEquals) {
			return equalsBuilder;
		}
		if (lhs == rhs) {
			return equalsBuilder;
		}
		if (lhs == null || rhs == null) {
			equalsBuilder.setEquals(false);
			return equalsBuilder;
		}
		if (lhs.length != rhs.length) {
			equalsBuilder.setEquals(false);
			return equalsBuilder;
		}
		for (int i = 0; i < lhs.length && thisIsEquals; ++i) {
			append(lhs[i], rhs[i], equalsBuilder, thisIsEquals);
		}
		return equalsBuilder;
	}

	/**
	* <p>Deep comparison of array of <code>float</code>. Length and all values are compared.</p> <p>The method  {@link #append(float,float)}  is used.</p>
	* @param lhs   the left hand <code>float[]</code>
	* @param rhs   the right hand <code>float[]</code>
	* @return  EqualsBuilder - used to chain calls.
	*/
	public EqualsBuilder append(final float[] lhs, final float[] rhs, boolean thisIsEquals,
			EqualsBuilder equalsBuilder) {
		if (!thisIsEquals) {
			return equalsBuilder;
		}
		if (lhs == rhs) {
			return equalsBuilder;
		}
		if (lhs == null || rhs == null) {
			equalsBuilder.setEquals(false);
			return equalsBuilder;
		}
		if (lhs.length != rhs.length) {
			equalsBuilder.setEquals(false);
			return equalsBuilder;
		}
		for (int i = 0; i < lhs.length && thisIsEquals; ++i) {
			append(lhs[i], rhs[i], thisIsEquals, equalsBuilder);
		}
		return equalsBuilder;
	}

	/**
	* <p>Test if two <code>short</code>s are equal.</p>
	* @param lhs   the left hand <code>short</code>
	* @param rhs   the right hand <code>short</code>
	* @return  EqualsBuilder - used to chain calls.
	*/
	public EqualsBuilder append(final short lhs, final short rhs, EqualsBuilder equalsBuilder, boolean thisIsEquals) {
		if (!thisIsEquals) {
			return equalsBuilder;
		}
		equalsBuilder.setEquals(lhs == rhs);
		return equalsBuilder;
	}

	/**
	* <p>Deep comparison of array of <code>short</code>. Length and all values are compared.</p> <p>The method  {@link #append(short,short)}  is used.</p>
	* @param lhs   the left hand <code>short[]</code>
	* @param rhs   the right hand <code>short[]</code>
	* @return  EqualsBuilder - used to chain calls.
	*/
	public EqualsBuilder append(final short[] lhs, final short[] rhs, boolean thisIsEquals,
			EqualsBuilder equalsBuilder) {
		if (!thisIsEquals) {
			return equalsBuilder;
		}
		if (lhs == rhs) {
			return equalsBuilder;
		}
		if (lhs == null || rhs == null) {
			equalsBuilder.setEquals(false);
			return equalsBuilder;
		}
		if (lhs.length != rhs.length) {
			equalsBuilder.setEquals(false);
			return equalsBuilder;
		}
		for (int i = 0; i < lhs.length && thisIsEquals; ++i) {
			append(lhs[i], rhs[i], equalsBuilder, thisIsEquals);
		}
		return equalsBuilder;
	}

	/**
	* <p>Test if two <code>char</code>s are equal.</p>
	* @param lhs   the left hand <code>char</code>
	* @param rhs   the right hand <code>char</code>
	* @return  EqualsBuilder - used to chain calls.
	*/
	public EqualsBuilder append(final char lhs, final char rhs, EqualsBuilder equalsBuilder, boolean thisIsEquals) {
		if (!thisIsEquals) {
			return equalsBuilder;
		}
		equalsBuilder.setEquals(lhs == rhs);
		return equalsBuilder;
	}

	/**
	* <p>Deep comparison of array of <code>char</code>. Length and all values are compared.</p> <p>The method  {@link #append(char,char)}  is used.</p>
	* @param lhs   the left hand <code>char[]</code>
	* @param rhs   the right hand <code>char[]</code>
	* @return  EqualsBuilder - used to chain calls.
	*/
	public EqualsBuilder append(final char[] lhs, final char[] rhs, boolean thisIsEquals, EqualsBuilder equalsBuilder) {
		if (!thisIsEquals) {
			return equalsBuilder;
		}
		if (lhs == rhs) {
			return equalsBuilder;
		}
		if (lhs == null || rhs == null) {
			equalsBuilder.setEquals(false);
			return equalsBuilder;
		}
		if (lhs.length != rhs.length) {
			equalsBuilder.setEquals(false);
			return equalsBuilder;
		}
		for (int i = 0; i < lhs.length && thisIsEquals; ++i) {
			append(lhs[i], rhs[i], equalsBuilder, thisIsEquals);
		}
		return equalsBuilder;
	}

	/**
	* <p>Test if two <code>byte</code>s are equal.</p>
	* @param lhs   the left hand <code>byte</code>
	* @param rhs   the right hand <code>byte</code>
	* @return  EqualsBuilder - used to chain calls.
	*/
	public EqualsBuilder append(final byte lhs, final byte rhs, EqualsBuilder equalsBuilder, boolean thisIsEquals) {
		if (!thisIsEquals) {
			return equalsBuilder;
		}
		equalsBuilder.setEquals(lhs == rhs);
		return equalsBuilder;
	}

	/**
	* <p>Deep comparison of array of <code>byte</code>. Length and all values are compared.</p> <p>The method  {@link #append(byte,byte)}  is used.</p>
	* @param lhs   the left hand <code>byte[]</code>
	* @param rhs   the right hand <code>byte[]</code>
	* @return  EqualsBuilder - used to chain calls.
	*/
	public EqualsBuilder append(final byte[] lhs, final byte[] rhs, boolean thisIsEquals, EqualsBuilder equalsBuilder) {
		if (!thisIsEquals) {
			return equalsBuilder;
		}
		if (lhs == rhs) {
			return equalsBuilder;
		}
		if (lhs == null || rhs == null) {
			equalsBuilder.setEquals(false);
			return equalsBuilder;
		}
		if (lhs.length != rhs.length) {
			equalsBuilder.setEquals(false);
			return equalsBuilder;
		}
		for (int i = 0; i < lhs.length && thisIsEquals; ++i) {
			append(lhs[i], rhs[i], equalsBuilder, thisIsEquals);
		}
		return equalsBuilder;
	}
}